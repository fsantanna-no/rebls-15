\documentclass{acm_proc_article-sp}

\usepackage{xspace}
\newcommand{\CEU}{\textsc{C\'{e}u}\xspace}
\newcommand{\code}[1] {{\small{\texttt{#1}}}}

\usepackage{verbatim}
\usepackage{color}
\definecolor{light}{gray}{0.87}
\definecolor{dark}{gray}{0.30}
%\definecolor{light}{rgb}{.90,.90,.90}
\definecolor{darkgreen}{rgb}{0,.50,0}
\definecolor{darkblue}{rgb}{0,0,.50}
\definecolor{darkred}{rgb}{.50,0,0}
\definecolor{darkpur}{rgb}{.50,0,.50}

\usepackage{listings}
%\usepackage{textcomp}
\lstset{
%columns=fullflexible,
%basicstyle=\ttfamily,
escapeinside={||},
mathescape=true,
    language=C, % choose the language of the code
    basicstyle=\fontfamily{pcr}\selectfont\scriptsize\color{black},
    keywordstyle=\color{black}\bfseries, % style for keywords
    numbers=none, % where to put the line-numbers
    numberstyle=\tiny, % the size of the fonts that are used for the line-numbers
    backgroundcolor=\color{light},
    showspaces=false, % show spaces adding particular underscores
    showstringspaces=false, % underline spaces within strings
    showtabs=false, % show tabs within strings adding particular underscores
    %frame=single, % adds a frame around the code
    tabsize=2, % sets default tabsize to 2 spaces
    %rulesepcolor=\color{gray}
    captionpos=b, % sets the caption-position to bottom
    breaklines=false, % sets automatic line breaking
    %breakatwhitespace=false,
    numbersep=2em,
    emph={par,or,hor,do,end,loop,await,emit,input,event,call,with,%
          var,and,then,else,C,return,pure,deterministic,nohold,finalize,%
          class, every, FOREVER, this, spawn, in, pool, watching, until, 
          interface, each, abort, when, signal, PROC, CHAN, SIGNAL, PAR, not,
          bool, data, tag, escape, new, traverse},
    emphstyle={\bfseries},
    commentstyle=\color{dark}\scriptsize,
    %xleftmargin=20pt,
    %xrightmargin=20pt,
    framesep=20pt,
    %upquote=true,
    %aboveskip={1.5\baselineskip},
}

\begin{document}

\title{Reactive Traversal of Recursive Data Types (?!)}
%\subtitle{[Extended Abstract]

\numberofauthors{3}
\author{
\alignauthor
Francisco Sant'Anna \\
    \affaddr{Departamento de Inform\'atica --- PUC-Rio, Brazil} \\
    \email{fsantanna@inf.puc-rio.br}
\alignauthor
Hisham Muhammad \\
    \affaddr{Departamento de Inform\'atica --- PUC-Rio, Brazil} \\
    \email{hisham@inf.puc-rio.br}
\alignauthor
Johnicholas Hines \\
    \affaddr{Affiliation} \\
    \email{email@domain.com}
}

\maketitle
\begin{abstract}
We propose a structured mechanism to traverse recursive data types 
incrementally, in successive reactions to input events.
\code{traverse} is an iterator-like anonymous block that can be invoked 
recursively and suspended at any point, retaining the full state and stack 
frames alive.
\code{traverse} is designed for the synchronous language \CEU, inheriting all 
existing concurrency functionality, such as parallel compositions with 
orthogonal abortion, static memory management, and bounded memory and reaction 
time.
We present three application scenarios that take advantage of recursive and 
reactive behavior: \emph{incremental computation}, \emph{behavior trees}, and 
\emph{control-oriented domain specific languages}.

\begin{comment}
MIX OF:
\begin{itemize}
    \item recursive calls to anonymous closures
    \item each instance---many co-routines
\end{itemize}

DESIGNED FOR \CEU:
\begin{itemize}
    \item lexical compositions
    \item static memory management
    \item bounded execution/memory
    \item reactive
    \item mutation
\end{itemize}
\end{comment}

\end{abstract}

\category{D.3.3}{Programming Languages}{Language Constructs and Features}

\terms{Design, Languages}

\keywords{Incremental Computation, Structured Programming, Behavior Trees, Domain Specific Languages}

\section{Introduction}

...

... \CEU~\cite{ceu.sensys13,ceu.mod15}

...

\newpage
\section{C\'eu}

\begin{comment}
\item adts
\item description
\item expansion: pool / recursive spawn
\item mutation / safety / watching
\end{comment}

\begin{figure}%[t]
\begin{lstlisting}[numbers=left,xleftmargin=3em]
input void RESET;   // declares an external event
var int v = 0;     // variable shared by the trails
par do
   loop do       // 1st trail
      await 1s;
      v = v + 1;
      _printf("v = %d\n", v);
   end
with
   loop do       // 2nd trail
      await RESET;
      v = 0;
   end
end
\end{lstlisting}
\caption{ Introductory example in \CEU.
\label{lst.intro}
}
\end{figure}

\CEU is a concurrent and reactive language in which the lines of execution, 
known as \emph{trails}, react all together continuously and in synchronous 
steps to external stimuli.
The introductory example in Figure~\ref{lst.intro} defines an input event 
\code{RESET} (line 1), a shared variable \code{v} (line 2), and starts two 
trails with the \code{par} construct (lines 3-14): the first (lines 4-8) 
increments variable \code{v} on every second and prints its value on screen; 
the second (lines 10-13) resets \code{v} on every external request to 
\code{RESET}.
\CEU is tightly integrated with \emph{C} and can access libraries of the 
underlying platform directly by prefixing symbols with an underscore (e.g., 
\code{\_printf(<...>)}, in line 7).

In the synchronous model of \CEU, a program reacts to an occurring event 
completely before handling the next.
%
A reaction represents a logical instant in which all trails awaiting the 
occurring event awake and execute, one after the other, until they await again 
or terminate.
%
During a reaction, the environment is invariant and does not interrupt the 
running trails%
\footnote{
The actual implementation enqueues incoming input events to process them in 
further reactions.
}.
If multiple trails react to the same event, the scheduler employs lexical 
order, i.e., the trail that appears first in the source code executes first.
%
For this reason, programs are deterministic even in the presence of side 
effects in concurrent lines of execution.
%
To avoid infinite execution for reactions, \CEU ensures that all loops contain 
\code{await} statements~\cite{ceu.sensys13}.

\subsection{Recursive Data Types}

\CEU supports algebraic data types (ADTs) as a safer alternative to C's 
\code{struct}, \code{union}, and \code{enum} definitions.
However, \CEU preserves the mutable semantics of data types in C, and extends 
it with static memory management.
For this reason, ADTs in \CEU differ in fundamental ways from functional 
algebraic data types (\emph{a la} Haskell and ML).
Currently, there is no parametric support for ADTs in \CEU.

% rebls-15/list/list.ceu
\begin{figure}[t]
\begin{lstlisting}[numbers=left,xleftmargin=3em]
data List with
   tag NIL;
or
   tag CONS with
      var int   head;
      var List* tail;
   end
end

do
   pool List[1] l1;
   l1 = new List.CONS(1,
             List.CONS(2,
              List.NIL()));
   _printf("%d, %d\n", l1:CONS.head,
                  l1:CONS.tail:NIL);
      // prints 1, 1
end

do
   pool List[] l2;
   l2 = new List.CONS(1,
             List.CONS(2,
              List.NIL()));
   l2:CONS.tail = new List.CONS(3, List.NIL());
   _printf("%d\n", l2:CONS.tail:CONS.head);
      // prints 3 (2 has been freed)
end
\end{lstlisting}
\caption{
A recursive \code{List} data type definition (lines 1--8) and uses (lines 
10--18 and 20--28).
\label{lst.data.list}
}
\end{figure}

Figure~\ref{lst.data.list} illustrates the recursive \code{List} data type, 
which is either an empty list \code{NIL} (line 2) or a \code{CONS} with a value 
in the field \code{head} and a pointer to the rest of the list in the field 
\code{tail} (lines 4--7).

In the first block (lines 10--18), the \code{pool} declaration of \code{l1} 
represents the root of the list and also specifies a memory pool to hold all of 
its elements (line 10).
We limit \code{l1} to contain at most 1 element (i.e., \code{List[1]}).
The declaration also implicitly initializes the root to be the base case of the 
associated data type (i.e., \code{List.NIL}).
Then, we mutate the root element to point to a dynamically allocated list of 
two elements (lines 12--14).
The assignment infers the destination memory pool based on the \emph{l-val} of 
the expression (i.e., \code{l1}).
In this case, only the allocation of first element succeeds, with the failed 
allocation returning the base case of the data type (i.e., \code{List.NIL}).
The print command (line 15) outputs \emph{``1, 1''}: the \code{head} of the 
first element (the operator \code{`:'} is equivalent to C's \code{`->'}) and 
the \code{NIL} check of the second element.
Due to static memory management, when \code{l1} goes out of scope, at the end 
of the block (line 18), all elements in the list are automatically deallocated.

In the second block (lines 20--28), we declare the \code{l2} pool with an
unbounded memory limit (i.e., \code{List[]} in line 21).
Now, the two-element allocation succeeds (lines 22--24).
Then, we mutate the tail of the first element to point to a newly allocated 
element, which also succeeds (line 25).
The print command (line 26) outputs \emph{``3''}, the new \code{head} of the 
second element.
In the moment of the mutation, the old subtree is completely removed from 
memory.
Finally, the end of the block (line 28) deallocates the pool along with all of 
its elements.

%TODO: invalid tag generates runtime error

Data types in \CEU have a number of limitations:
given that mutations deallocate whole subtrees, data types cannot represent 
general graphs (in particular, they cannot contain cycles);
elements in different pools cannot be mixed;
and pointers to subtrees (i.e., weak references) must be observed as they can 
be deallocated at any time (to be discussed in Section~\ref{sec.traverse}).

\subsection{Traversing Data Types}
\label{sec.traverse}

\CEU introduces a structured mechanism to traverse data types.
The \code{traverse} construct integrates well with the synchronous execution 
model, supporting nested control compositions, such as \code{await} and all 
\code{par} variations.
It also preserves explicit lexical scopes with static memory management.

% rebls-15/list/list.ceu
\begin{figure}%[t]
\begin{lstlisting}[numbers=left,xleftmargin=3em]
pool List[] l = new List.CONS(1,
                     List.CONS(2,
                      List.CONS(3,
                       List.NIL())));

var int sum =
   traverse e in l do
      if e:NIL then
         escape 0;
      else
         var int sum_tail = traverse e:CONS.tail;
         escape sum_tail + e:CONS.head;
      end
   end;
_printf("sum = %d\n", sum);
\end{lstlisting}
%\rule{8.5cm}{0.37pt}
\caption{
Calculating the \emph{sum} of a list.
\label{lst.sum}
}
\end{figure}

The example in Figure~\ref{lst.sum} creates a list (lines 1--4) and traverses 
it to calculate the sum of elements (lines 6--15).
The \code{traverse} block (line 7) starts with the element \code{e} pointing to 
the root of the list \code{l}.
The \code{escape} statement (lines 9 and 12) returns a value to be assigned to 
the \code{sum} (line 6).
A \code{NIL} list has \code{sum=0} (lines 8-9).
A \code{CONS} list needs to calculate the \code{sum} of its tail recursively, 
invoking \code{traverse} again (line 11), which will create a nested instance 
of the enclosing \code{traverse} block (lines 7--14), now with \code{e} 
pointing to the \code{e:CONS.tail}.
Without nested control mechanisms, \code{traverse} is just syntactic sugar for 
anonymous closures called recursively.

% rebls-15/list/react.ceu
\begin{figure}%[t]
\begin{lstlisting}[numbers=left,xleftmargin=3em]
pool List[] l = <...>;  // 1, 2, 3
var int sum =
   traverse e in l do
      if e:NIL then
         escape 0;
      else
         watching e do
            _printf("me = %d\n", e:CONS.head);
            await 1s;
            var int sum_tail = traverse e:CONS.tail;
            escape sum_tail + e:CONS.head;
         end
         escape 0;
      end
   end;
_printf("sum = %d\n", sum);
\end{lstlisting}
%\rule{8.5cm}{0.37pt}
\caption{
Calculating the \emph{sum} of a list, one element each second.
\label{lst.sum.react}
}
\end{figure}
% TODO: react.ceu with mutation

To distinguish \code{traverse} from standard recursive functions, 
Figure~\ref{lst.sum.react} extends the body of the previous example with 
reactive behavior.
For each recursive iteration, the \code{traverse} prints the current 
\code{head} (line 8) and awaits 1 second before traversing the \code{tail} 
(lines 9--10).
In \CEU, all accesses to pointers that cross \code{await} statements must be 
protected with \code{watching} blocks~\cite{ceu.mod15}.
This ensures that if side effects occurring in parallel affect the pointed 
object, no harming code executes because the whole block is aborted.
In the example (lines 7--12), if the list is mutated during that 1 second and 
the specific element is removed from memory, we simply ignore the whole subtree 
and return 0.

Note that for bounded pools (e.g., \code{List[3] l}), we can infer at compile 
time the maximum number of ``stack frames'' required for \code{traverse}.
In addition, we can also enforce bounded execution time by asserting that the 
structure of the recursive steps converge to the base cases.
This is an important requirement for constrained and real-time embedded 
systems, which is the original application domain of \CEU~\cite{ceu.sensys13}.

% TODO: abstract fold example?
% TODO: or mention that is not the focus here
% TODO: or mention that abstractions will be used in the applications
\begin{comment}
\begin{figure}%[t]
\begin{lstlisting}[numbers=left,xleftmargin=3em]
class FoldL with
   pool List[]&   l;
   pool Action[]& actions;
   var  int&     acc;
do
   traverse e in l do
      if e:CONS then
         var Action*? a =
            spawn Action in actions with
               this.e    = e;
               action.acc = acc;
            end
         await *a;
      end
   end
end
\end{lstlisting}
%\rule{8.5cm}{0.37pt}
\caption{
Calculating the \emph{sum} of a list.
\label{lst.sum}
}
\end{figure}
\end{comment}

\section{Applications}

incremental computation, behavior trees, control-dominated DSLs

...

\subsection{Incremental Computation}

...

\begin{itemize}
\item gray binary generation?
\end{itemize}

...

\subsection{Behavior Trees}

The term ``Behavior Trees'' denotes a family of DSLs 
used for Game AI.
The term is loose, because different games use different languages,
but generally it indicates an interpreted domain-specific language
for creature behavior that includes at least sequence and selection combinators,
and which are ``ticked'' periodically.

The semantics of the sequence combinator can be understood as short-circuit evaluation of a conjunction;
the Seq node ticks its left subtree until it finishes,
and if it finishes successfully, ticks its right subtree until it finishes.
The semantics of the selection combinator can be understood as short-circuit evaluation of an alternation;
the Sel node ticks its left subtree until it finishes,
and if it did not finish successfully, ticks its right subtree until it finishes.

This skeleton, augmented with leaves that test properties, set properties, perform animations and sounds,
and other custom combinators, can be preferable to finite state machines (hierarchical, augmented, or otherwise) for authoring Game AI.

Ceu's parallel features make implementing a parallel combinator for behavior trees much easier.

...

\begin{itemize}
\item ?
\end{itemize}

...

\subsection{Domain Specific Languages}

...

\begin{itemize}
\item LOGO Turtle?
\end{itemize}

...

\begin{figure}%[t]
\begin{lstlisting}[numbers=left,xleftmargin=3em]
data Command with
    tag NOTHING;
or
    tag ROTATE with
        var int angle;
    end
or
    tag MOVE with
        var int pixels;
    end
or
    tag AWAIT with
        var int ms;
    end
or
    tag SEQUENCE with
        var Command* one;
        var Command* two;
    end
or
    tag REPEAT with
        var int      times;
        var Command* command;
    end
or
    tag PAROR with
        var Command* one;
        var Command* two;
    end
end
end
\end{lstlisting}
%\rule{8.5cm}{0.37pt}
\caption{ DSL for a LOGO turtle.
\label{lst.turtle.dsl}
}
\end{figure}

\begin{figure}%[t]
\begin{lstlisting}[numbers=left,xleftmargin=3em]
class Interpreter with
    pool Command[]& cmds;
    var  Turtle&    turtle;
do
    traverse cmd in cmds do
        watching cmd do
            if cmd:AWAIT then
                await (cmd:AWAIT.ms) ms;

            else/if cmd:ROTATE then
                do TurtleRotate with
                    this.turtle = turtle;
                    this.angle  = cmd:ROTATE.angle;
                end;

            else/if cmd:MOVE then
                do TurtleMove with
                    this.turtle  = turtle;
                    this.pixels = cmd:MOVE.pixels;
                end;

            else/if cmd:PAROR then
                par/or do
                    traverse cmd:PAROR.one;
                with
                    traverse cmd:PAROR.two;
                end

            else/if cmd:SEQUENCE then
                traverse cmd:SEQUENCE.one;
                traverse cmd:SEQUENCE.two;

            else/if cmd:REPEAT then
                loop i in cmd:REPEAT.times do
                    traverse cmd:REPEAT.command;
                end
            end
        end
    end
end
\end{lstlisting}
%\rule{8.5cm}{0.37pt}
\caption{ The turtle interpreter.
\label{lst.turtle.interpreter}
}
\end{figure}

\section{Related Work}

...

\section{Conclusion}

...

\bibliographystyle{abbrv}
\bibliography{rebls-15}
\balancecolumns
\end{document}

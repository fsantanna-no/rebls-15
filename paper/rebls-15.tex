%\documentclass{acm_proc_article-sp}
\documentclass{sig-alternate}

\setlength{\paperheight}{11in}
\setlength{\paperwidth}{8.5in}
\usepackage[
  pass,% keep layout unchanged 
  % showframe,% show the layout
]{geometry}
\usepackage{balance}

\usepackage{xspace}
\newcommand{\CEU}{\textsc{C\'{e}u}\xspace}
\newcommand{\code}[1] {{\small{\texttt{#1}}}}
\newcommand{\MM}[1] {\textcircled{\tiny{\textsf{#1}}}}

\usepackage{verbatim}
\usepackage{enumitem}
%\usepackage{epstopdf}

\usepackage{color}
\definecolor{light}{gray}{0.87}
\definecolor{dark}{gray}{0.30}
%\definecolor{light}{rgb}{.90,.90,.90}
\definecolor{darkgreen}{rgb}{0,.50,0}
\definecolor{darkblue}{rgb}{0,0,.50}
\definecolor{darkred}{rgb}{.50,0,0}
\definecolor{darkpur}{rgb}{.50,0,.50}

% \input bnf.tex

\usepackage{listings}
%\usepackage{textcomp}
\usepackage{url}
\lstset{
%columns=fullflexible,
%basicstyle=\ttfamily,
escapeinside={||},
    %mathescape=true,
    language=C, % choose the language of the code
    basicstyle=\fontfamily{pcr}\selectfont\scriptsize\color{black},
    keywordstyle=\color{black}\bfseries, % style for keywords
    numbers=none, % where to put the line-numbers
    numberstyle=\tiny, % the size of the fonts that are used for the line-numbers
    backgroundcolor=\color{light},
    showspaces=false, % show spaces adding particular underscores
    showstringspaces=false, % underline spaces within strings
    showtabs=false, % show tabs within strings adding particular underscores
    %frame=single, % adds a frame around the code
    tabsize=2, % sets default tabsize to 2 spaces
    %rulesepcolor=\color{gray}
    captionpos=b, % sets the caption-position to bottom
    breaklines=false, % sets automatic line breaking
    %breakatwhitespace=false,
    numbersep=2em,
    % C was used in the blocksworld example to refer to block C and nowhere else
    emph={par,or,hor,do,end,loop,await,emit,input,event,call,with,%
          var,and,then,else,return,pure,deterministic,nohold,finalize,%
          class, every, FOREVER, this, spawn, in, pool, watching, until, 
          interface, each, abort, when, signal, PROC, CHAN, SIGNAL, PAR, not,
          bool, data, tag, escape, new, traverse},
    emphstyle={\bfseries},
    commentstyle=\color{dark}\scriptsize,
    %xleftmargin=20pt,
    %xrightmargin=20pt,
    framesep=20pt,
    %upquote=true,
    %aboveskip={1.5\baselineskip},
}

\setlength\paperheight {11in}
\setlength\paperwidth {8.5in}

% No space between bibliography items:
\let\oldthebibliography=\thebibliography
  \let\endoldthebibliography=\endthebibliography
  \renewenvironment{thebibliography}[1]{%
    \begin{oldthebibliography}{#1}%
      \setlength{\parskip}{0ex}%
      \setlength{\itemsep}{0ex}%
  }%
  {%
    \end{oldthebibliography}%
  }
\setlength{\parindent}{5mm}

\newcommand{\compresslist}{
	\setlength{\itemsep}{1pt}
	\setlength{\parskip}{0pt}
	\setlength{\parsep}{0pt}
}

\newenvironment{itemize*}%
  {\begin{itemize}%
    \setlength{\itemsep}{0pt}%
    \setlength{\parskip}{0pt}}%
  {\end{itemize}}
\usepackage{enumitem}
\setlist{nolistsep}

%\setlength{\belowcaptionskip}{-100pt}
%\setlength{\textfloatsep}{10pt plus 1.0pt minus 2.0pt}
%\setlength{\floatsep}{12.0pt plus 2.0pt minus 2.0pt}
%\setlength{\textfloatsep}{20.0pt plus 2.0pt minus 4.0pt}
%\setlength{\intextsep}{12.0pt plus 2.0pt minus 2.0pt}
%\setlength{\dbltextfloatsep}{20.0pt plus 2.0pt minus 4.0pt}
%\setlength{\dblfloatsep}{12.0pt plus 2.0pt minus 2.0pt}
%\setlength{\abovecaptionskip}{10.0pt}
%\setlength{\belowcaptionskip}{0.0pt}
%\setlength{\textfloatsep}{\baselineskip plus 0.2\baselineskip minus 
%0.2\baselineskip}
\setlength{\textfloatsep}{5pt}

\begin{document}

\title{Reactive Traversal of Recursive Data Types}
%\subtitle{[Extended Abstract]

\numberofauthors{3}
\author{
\alignauthor
Francisco Sant'Anna \\
    \affaddr{Departamento de Inform\'atica --- PUC-Rio, Brazil} \\
    \email{fsantanna@inf.puc-rio.br}
\alignauthor
Hisham Muhammad \\
    \affaddr{Departamento de Inform\'atica --- PUC-Rio, Brazil} \\
    \email{hisham@inf.puc-rio.br}
\alignauthor
Johnicholas Hines \\
    \affaddr{IDEXX Laboratories} \\
    \email{johnicholas.hines@gmail.com}
}

\maketitle
\begin{abstract}
We propose a structured mechanism to traverse recursive data types 
incrementally, in successive reactions to external input events.
\code{traverse} is an iterator-like anonymous block that can be invoked 
recursively and suspended at any point, retaining the full state and stack 
frames alive.
\code{traverse} is designed for the synchronous language \CEU, inheriting all 
of its concurrency functionality and safety properties, such as parallel 
compositions with orthogonal abortion, static memory management, and bounded 
reaction time and memory usage.
We discuss three applications in the domain of control-oriented DSLs that 
contain reactive and recursive behavior at the same time.

\begin{comment}
MIX OF:
\begin{itemize}
    \item recursive calls to anonymous closures
    \item each instance---many co-routines
\end{itemize}

DESIGNED FOR \CEU:
\begin{itemize}
    \item lexical compositions
    \item static memory management
    \item bounded execution/memory
    \item reactive
    \item mutation
\end{itemize}
\end{comment}

\end{abstract}

\category{D.3.3}{Programming Languages}{Language Constructs and Features}

\terms{Design, Languages}

\keywords{Behavior Trees, Domain Specific Languages, Incremental Computation, 
Logo, Recursive Data Types, Structured Programming, Reactive Programming}

\section{Introduction}

\begin{comment}
All examples have working implementations:

- TODO: compare the real code with the listing

\begin{itemize}
\item label "lst.list":               rebls-15/list/list.ceu
\item label "lst.list.sum":           rebls-15/list/list.ceu
\item label "lst.list.sum.react":     rebls-15/list/list.ceu
%
\item label "lst.bt1":                rebls-15/bts-ceu/btree-1.ceu
\item label "lst.bt1.interpreter":    rebls-15/bts-ceu/btree-1.ceu
\item label "lst.bt1.leaf":           rebls-15/bts-ceu/domain-1.ceu
%
\item label "lst.turtle.dsl":         rebls-15/turtle/turtle-2.ceu
\item label "lst.turtle.interpreter": rebls-15/turtle/turtle-2.ceu
\item label "lst.turtle.queue":       rebls-15/turtle/turtle-7.ceu
\end{itemize}
\end{comment}

The facilities a given language offers for constructing data types have a 
direct impact on the nature of algorithms that programmers will write on that 
language.
%The design of such facilities must take into account the constraints imposed 
%by the rest of the language.
As an example, the aim for referential transparency in functional languages 
enforces data structures to be immutable.
Under these constraints, one must avoid excessive memory copying through 
specialized algorithms~\cite{okasaki.purely}.

In this paper, we discuss the design of recursive data types and an associated
control facility for a language developed under a different set of
constraints.
\CEU~\cite{ceu.sensys13,ceu.mod15} is an imperative, concurrent and reactive 
language in which lines of execution, known as \emph{trails}, react 
together continuously and in synchronous steps to external stimuli.
%Being an imperative language, \CEU features mutable data.
\CEU supports mutable data, with static memory and safe pointer 
manipulation.
% even under concurrent trails with orthogonal abortion~\cite{ceu.mod15}.
However, these features are incompatible with garbage-collected immutable data 
structures, as well as with general records with arbitrary pointers such as 
\emph{structs} in C.
%Recursive data types in \CEU must, therefore, respect the language's
%memory management guarantees and their use must cope with the synchronous
%concurrency model.

The solution to this problem is twofold, with data and control aspects.
For data management, we introduce a restricted form of recursive data types 
that can describe trees (but not general graphs).
To control reactive behavior, we propose a structured mechanism that can 
traverse data types safely and incrementally, in successive reactions to 
events.
%\code{traverse} is an iterator-like anonymous block that can be invoked 
%recursively and suspended at any point, retaining the full state and stack 
%frames alive.
%
After we present the design of these constructs, we discuss three applications 
in the domain of control-oriented DSLs.
%The applications contain reactive and recursive behavior at the same time and 
%showcase the expressiveness of the proposed constructs.
%Then, we discuss some related work in Section~\ref{sec.related} and make 
%closing remarks in Section~\ref{sec.conclusion}.

\section{C\'eu constructs}
\label{sec.ceu}

\begin{figure}[t]
\begin{lstlisting}[numbers=left,xleftmargin=3em]
input void RESET;  // declares an external event
var int v = 0;     // variable shared by the trails
par do
   loop do         // 1st trail
      await 1s;
      v = v + 1;
      _printf("v = %d\n", v);
   end
with
   loop do         // 2nd trail
      await RESET;
      v = 0;
   end
end
\end{lstlisting}
\caption{ Introductory example in \CEU.
\label{lst.intro}
}
\end{figure}

%In this section, we present the constructs added to \CEU to support recursive
%data types with reactive traversal.

The introductory example%
\footnote{A screencast of all examples in the paper is available at 
\url{https://vimeo.com/135297440}.}
in Figure~\ref{lst.intro} gives a general flavor of \CEU.
It first defines an input event \code{RESET} (line 1), a shared variable 
\code{v} (ln. 2), and starts two trails with the \code{par} construct (ln. 
3-14): the first (ln. 4-8) increments variable \code{v} on every second and 
prints its value on screen; the second (ln. 10-13) resets \code{v} on every 
external request to \code{RESET}.
%\CEU is tightly integrated with \emph{C} and can access libraries of the 
%underlying platform directly by prefixing symbols with an underscore (e.g., 
%\code{\_printf(<...>)}, in line 7).

In the synchronous model of \CEU, a program reacts to an occurring event 
completely before handling the next.
%
A reaction represents a logical instant in which all trails awaiting the 
occurring event awake and execute \emph{atomically}, one after the other, until 
they await again or terminate.
%
As a consequence, all consecutive operations to shared variable \code{v} in 
Figure~\ref{lst.intro} are atomic because reactions to events \code{1s} and 
\code{RESET} can never interrupt each other.
%
If multiple trails awake to the same event, the scheduler employs lexical 
order, i.e., the trail that appears first in the source code executes first.
%
For this reason, programs are deterministic even in the presence of side 
effects in concurrent lines of execution.
%
To avoid infinite execution for reactions, \CEU ensures that all loops contain 
\code{await} statements~\cite{ceu.sensys13}.

\CEU relies on a source-to-source compiler that generates single-threaded code 
in \emph{C}.
The generated code has a negligible overhead in terms of memory and CPU usage 
in comparison to handcrafted event-driven code written directly in 
\emph{C}~\cite{ceu.sensys13}.

\subsection{Recursive Data Types}

The \code{data} construct in \CEU provides a safer alternative to C's
\code{struct}, \code{union}, and \code{enum} definitions.
All allocations are made in terms of a memory pool, and instances
must form a tree structure with respect to the pool's \emph{root element}.

Figure~\ref{lst.list} illustrates the recursive \code{List} data type,
declared as a tagged union (ln. 1--5).
The first tag of a recursive type has a special meaning and represents the 
union's \emph{null tag}.
In the example, the tag \code{NIL} also represents an empty list (ln. 2).
The second tag, \code{CONS} (ln. 4), represents list nodes.
%receives two arguments in the constructor: 
%an integer value for the \code{head} field and the rest of the list in the 
%recursive field \code{tail}.

\begin{comment}
A \code{data} entry
declares either a non-recursive structure containing a set of mutable fields
or a tagged union. A tagged union consists of a set of tag declarations, each
of which may be a bare tag or contain mutable fields. If any of the tag
declarations refers to the data type being declared, we have a recursive data
type. In this case, the first tag of the tagged union must be a bare tag, and
it will act as the union's null type: in \CEU, every recursive data type
is an option type.

%% (Uncomment \input bnf.tex above)
\begin{figure}[t]
\begingrammar
<data> : "data" <id> "with" <dataBody> "end" ";"

<dataBody> : <field>* | <tags>

<tags> : <tag> [ "or" <tags> ]* 

<tag> : "tag" <id> \{ ";" | "with" <field>* "end" \}

<field> : "var" <type> <id> ";"

\endgrammar
\caption{
The \code{data} construct in \CEU
}
\end{figure}
\end{comment}

In the first block of the example (ln. 7--16), we declare a \code{pool} of 
\code{List} objects of size 1 (ln. 8).
%
All pools have static memory management based on their enclosing lexical scope (ln.  
7--16).
%
The pool variable represents the root element, and is implicitly 
initialized to the \emph{null} tag of its data type, i.e., 
\code{lst1} receives \code{List.NIL} (ln. 8).
%
Then, we use the \code{=new} construct which performs
allocation and assignment at the same time (ln. 9--12):
it attempts to allocate a list of three elements (10, 20, and 30),
and assigns the result to \code{lst1}, which is also the destination memory 
pool for the allocation (inferred from the \emph{l-value} in the assignment).
%
Since the pool has size 1, only the allocation of first element succeeds, with 
the failed subtree allocation returning the \emph{null} tag (i.e., 
\code{List.NIL}).
The print command (ln. 13--14) outputs ``\texttt{10, 1}'': the \code{head} of 
the first element, and \emph{true} in the \code{NIL} check for the second 
element.
%
Finally, the end of the block (ln. 16) deallocates the pool along with all 
elements inside it.

In the second block (ln. 18--24), we declare the \code{lst2} pool with an 
unbounded memory limit (i.e., \code{List[]} in line 19).
Now, all allocations succeed (ln. 20)%
\footnote{To save space, in the next examples we omit the data type prefix in 
tags (e.g., \code{List.CONS} becomes \code{CONS}).}.
Then, we mutate the tail of the first element to point to a newly allocated 
element in the same pool, which also succeeds (ln. 21).
At the moment of the mutation, the old subtree (containing values  
``\texttt{20}'' and  ``\texttt{30}'') is completely removed from memory.
The print command (ln. 22) outputs ``\texttt{50}'', displaying the \code{head}
of the new second element.
%
Again, the end of the block (ln. 24) deallocates the pool along with all of its 
remaining elements.

%TODO: comment that invalid tag generates runtime error?

% rebls-15/list/list.ceu
\begin{figure}[t]
\begin{lstlisting}[numbers=left,xleftmargin=3em]
data List with
   tag NIL ();
or
   tag CONS (int head, List tail);
end

do
   pool List[1] lst1;
   lst1 = new List.CONS(10,
               List.CONS(20,
                List.CONS(30,
                 List.NIL()));
   _printf("%d, %d\n", lst1.CONS.head,
                       lst1.CONS.tail.NIL);
      // prints 10, 1
end

do
   pool List[] lst2;
   lst2 = new CONS(10, CONS(20, CONS(30, NIL()));
   lst2.CONS.tail = new CONS(50, NIL());
   _printf("%d\n", lst2.CONS.tail.CONS.head);
      // prints 50 (20 and 30 have been freed)
end
\end{lstlisting}
\caption{
A recursive \code{List} data type definition (ln. 1--5) with uses (ln. 
7--16 and 18--24).
\label{lst.list}
}
\end{figure}

In \CEU, recursive data types impose some restrictions.
Elements in different pools cannot be mixed without copying.
Types may contain arbitrary weak pointers, but weak pointers to \CEU
structures must be observed via the
\code{watching} construct, as they can be invalidated at any time
(to be discussed in Section~\ref{sec.traverse}).

%TODO: what kind of structure updates can be made through weak pointers?

\subsection{Traversing Data Types}
\label{sec.traverse}

% rebls-15/list/list.ceu
\begin{figure}[t]
\begin{lstlisting}[numbers=left,xleftmargin=3em]
pool List[3] lst = <...>;  // [10, 20, 30]

var int sum =
   traverse e in lst do
      if e:NIL then
         escape 0;
      else
         var int sum_tail = traverse e:CONS.tail;
         escape sum_tail + e:CONS.head;
      end
   end;

_printf("sum = %d\n", sum); // prints 60
\end{lstlisting}
\caption{
Calculating the \emph{sum} of a list.
\label{lst.list.sum}
}
\end{figure}

\CEU introduces the \code{traverse} structured mechanism for traversing 
recursive data types incrementally.
%The \code{traverse} construct integrates with the synchronous execution model 
%of \CEU and supports nested control compositions, such as \code{await} and all 
%\code{par} variations.
%It also preserves explicit lexical scopes with static memory management.
%
%We begin by showing the flavor of the construct through an example.
The code in Figure~\ref{lst.list.sum} creates a list (ln. 1) and traverses it 
to calculate the sum of elements (ln. 3--11).
The \code{traverse} block (ln. 4--11) starts with the element \code{e} 
pointing to the root of the list \code{lst}.
The \code{escape} statement (ln. 6,9) returns a value to the enclosing 
assignment to \code{sum} (ln. 3).
The sum of a \code{NIL} list is \code{0} (ln. 5--6)%
\footnote{
The operator \code{`:'}, as in \code{e:NIL}, is equivalent to C's \code{`->'}.
}.
A \code{CONS} list needs to calculate the \code{sum} of its tail recursively, 
invoking \code{traverse} again (ln. 8), which will create a nested instance of 
the enclosing \code{traverse} block (ln. 4--11), now with \code{e} pointing to 
\code{e:CONS.tail}.
Only after the complete recursive traversal of its subtree that the \code{CONS} 
clause adds its \code{head} and returns the sum (ln. 9).

\begin{figure*}[t]
\begin{minipage}[t]{0.48\linewidth}
% rebls-15/list/list.ceu
\begin{lstlisting}[numbers=left,xleftmargin=3.5em,title=\MM{C1} CODE-1: Original code (with \code{traverse})]
pool List[3] lst = <...>;  // [10, 20, 30]

par do
  var int sum =
    traverse e in lst do
      if e:NIL then
        escape 0;
      else
        watching e do
          _printf("me = %d\n", e:CONS.head);
          await 1s;
          var int sum_tail = traverse e:CONS.tail;
          escape sum_tail + e:CONS.head;
        end
        escape 0;
      end
    end;
  _printf("sum = %d\n", sum);
      // prints 60 (with no mutations)
with
  <...>
    lst.CONS.tail = NIL();
      // possible concurrent mutation
  <...>
end














.
\end{lstlisting}
\end{minipage}
%
\begin{minipage}[t]{0.52\linewidth}
\begin{lstlisting}[numbers=left,xleftmargin=3.5em,title=\MM{C2} CODE-2: Expanded code (without \code{traverse})]
pool List[3] lst = <...>;  // [10, 20, 30]

par do
  class Frame (Frame[3]& frames,
               _Dummy*   parent,
               List[3]*  e)
  do
    watching *this.parent do
      if e:NIL then
        escape 0;
      else
        watching e do
          _printf("me = %d\n", e:CONS.head);
          await 1s;
          do
            var _Dummy scope;
            var Frame* frame = spawn Frame(this.frames,
                                   &scope, e:CONS.tail)
                               in this.frames;
            var int sum_tail = await *frame;
          end
          escape sum_tail + e:CONS.head;
        end
        escape 0;
      end
    end
    escape 0;
  end
  pool Frame[3] frames;
  var _Dummy scope;
  var Frame* frame = spawn Frame(frames, &scope, lst)
                     in frames;
  var int sum = await *frame;
  _printf("sum = %d\n", sum); // prints 60
with
  <...>
    lst.CONS.tail = NIL();
      // possible concurrent mutation
  <...>
end

\end{lstlisting}
\end{minipage}
%
%\rule{17.5cm}{0.37pt}
\caption{
Calculating the \emph{sum} of a list, one element each second.
The \code{traverse} construct is a syntactic sugar that can be ``desugared'' 
with explicit organisms.
\label{lst.list.sum.react}
}
\end{figure*}

When used without event-based control mechanisms, as in 
Figure~\ref{lst.list.sum}, a \code{traverse} block is equivalent to an 
anonymous closure called recursively.
%
However, \code{traverse} complies with the event system and memory management 
discipline of \CEU and is an abstraction defined in terms of a more fundamental 
concept, \emph{organisms}~\cite{ceu.mod15}, which are objects with concurrent 
trails of execution (akin to Simula~\cite{simula}).
%; and orthogonal abortion, which handles cancellation of trails maintaining 
%memory consistency.
%
Figure~\ref{lst.list.sum.react} depicts the expansion of the \code{traverse} 
construct.

The example in \emph{CODE-1} of Figure~\ref{lst.list.sum.react} (\MM{C1}) 
extends the body of the previous example in Figure~\ref{lst.list.sum} with 
reactive behavior.
%
Now, for each recursive iteration, we print the current \code{head} 
and \code{await} 1 second before traversing the \code{tail} (ln. 10-12).
%
Note that while nested iterations of \code{traverse} await 1 second, all 
previous iterations are blocked, retaining their full state of execution.
%
Note also that a parallel trail (ln. 21--24) remains reactive in the 
meantime, and can mutate the list at any time.
%
We handle the issue of parallel mutations using the \code{watching} construct.
The \code{watching} block aborts if the object being watched
is released from memory~\cite{ceu.mod15}.
%
Using \code{watching e} (ln. 9--14) we ensure that if element \code{e}
is released from memory during \code{await} (ln. 11) due to a 
mutation in the list (ln. 22), we simply ignore the whole subtree and return 0 
(ln. 15).
%
\CEU enforces at compile time that all accesses to pointers that cross 
\code{await} statements are protected with an enclosing \code{watching} block.
%
This ensures that if concurrent side effects affect the pointed object, no code 
uses the stale pointer, because the whole block is aborted.

\emph{CODE-2} in Figure~\ref{lst.list.sum.react} (\MM{C2}) is the equivalent 
expansion of \MM{C1} without the \code{traverse} construct.
%
Because it contains concurrency constructs (i.e., \code{await} and 
\code{watching}), the body of the \code{traverse} (\MM{C1}: 6--16) is 
abstracted in an organism of the \code{Frame} class (\MM{C2}: 4--26), which is 
analogous to ``stack frames'' for subroutines in standard programming 
languages.
%
In \CEU, organisms also reside in lexically-scoped memory 
pools~\cite{ceu.mod15}, hence, the \code{pool} of frames (\MM{C2}: 29) is 
analogous to a runtime ``call stack''.
We limit the number of stack frames to match the exact maximum number of 
elements to traverse (\MM{C1}: 1 and \MM{C2}: 4, 29).
%
To ``call'' the first \code{traverse} iteration, we dynamically \code{spawn} a 
\code{Frame} instance into the \code{frames} pool (\MM{C2}: 31--32), which runs 
implicitly in parallel with the rest of the application (e.g., \MM{C2}: 36--39)~\cite{ceu.mod15}.
Then, we immediately \code{await} the termination of this \code{frame} 
(\MM{C2}: 33).
Only after the whole traversal finishes 
that we acquire the \code{sum} and print it (\MM{C2}: 33--34).

A \code{Frame} receives three arguments in the constructor (\MM{C2}: 4--6):
a reference to a \code{pool} (to recursively \code{spawn} new frames);
a pointer to its parent scope (to handle abortion);
and a pointer to the subtree of the data type (to be able to manipulate it).
%
The \code{Frame} constructor for the first call (\MM{C2}: 31--32) receives the 
static pool of frames, a dummy \code{scope} organism attached to the current 
scope, and the original tree to traverse (\MM{C1}: 5).
%
The \code{Frame} constructor for recursive calls (\MM{C2}: 17--19) receives the 
same pool of frames, another dummy \code{scope} as parent, and the 
subtree for the recursive invocation (\MM{C1}: 12).
%
The \code{Frame} body (\MM{C2}: 8--27) watches the dummy organism attached to 
its \code{parent} scope and aborts if the parent terminates.
Watching an object in the parent scope guarantees that the hierarchy in the call stack 
is preserved, i.e., that there are no orphan frames executing.
%
The remaining code is almost the same in the original \code{traverse} body and 
in the \code{Frame} body (\MM{C1}: 6--16 and \MM{C2}: 9--25), with the 
exception of the recursive invocation explained above (\MM{C2}: 16--19).

As the expansion illustrates, three aspects make \code{traverse} fundamentally 
different from recursive function calls:
%
\begin{enumerate}
\item Each \code{traverse} invocation spawns a new organism for the frame which 
can execute concurrently with other parts of the application.
Also, each frame itself can execute arbitrary code in \CEU with concurrent 
trails (to be illustrated in Section~\ref{sec.apps}).
%
\item A \code{traverse} is attached to a lexically-scoped memory pool for 
specific a data structure.
Therefore, we can infer at compile time the maximum traversal depth if the data 
is bounded (e.g., \code{List[3] lst}).
Enforcing bounded limits is an important requirement for constrained and 
real-time embedded systems, which is the original application domain of 
\CEU~\cite{ceu.sensys13}.
In addition, when a recursive data structured goes out of scope, all associated 
stack frames are automatically aborted, given that the pool of frames expands 
to a narrower lexical scope (e.g., \MM{C2}: 1 \emph{vs.} 29)~\cite{ceu.mod15}.
%
\item The execution body of a \code{traverse} block is implicitly wrapped by a 
concurrency construct that watches for mutations of the current node.
In practice, this means that it reacts consistently if another trail of 
execution modifies the data structure being traversed.
\end{enumerate}

We believe that the \code{traverse} construct, more than a simple convenience, 
considerably reduces the complexity of programs, handling automatically 
hierarchy of behaviors associated with recursive data types.

%TODO: expansion is simplified:
% option type, mem fail, passing arguments, outer closure

\begin{comment}
\CEU can also ensure termination for \code{traverse}
% construct can also enforce bounded execution time, by performing a limited 
% number of steps, each of them in a separate synchronous reaction.
%This can be asserted
by verifying that the structure of the
recursive steps converge to the base cases, or by limiting the maximum number 
of recursive invocations based on the size of the data type pool.
If a pool is limited to at most \emph{N} elements, then you can have at most 
\emph{N} alive \code{traverse} bodies.
Enforcing execution limits is an important requirement for
constrained and real-time embedded systems, which is the original application
domain of \CEU~\cite{ceu.sensys13}.

% TODO: abstract fold example?
% TODO: or mention that is not the focus here
% TODO: or mention that abstractions will be used in the applications
\begin{figure}[t]
\begin{lstlisting}[numbers=left,xleftmargin=3em]
class FoldL with
   pool List[]&   lst;
   pool Action[]& actions;
   var  int&     acc;
do
   traverse e in lst do
      if e:CONS then
         var Action*? a =
            spawn Action(e, acc);
         await *a;
      end
   end
end
\end{lstlisting}
%\rule{8.5cm}{0.37pt}
\caption{
Calculating the \emph{sum} of a list.
\label{lst.sum}
}
\end{figure}
\end{comment}

\section{Applications}
\label{sec.apps}

In this section, we present three applications that explore the reactive nature 
of the \code{traverse} construct.
We start with \emph{Behavior Trees} used in video games for AI modeling.
Then, we show a \emph{Logo Turtle} that can execute commands in parallel.
Finally, we extend the Turtle example with a dynamic and concurrent queue of 
commands that can affect the running program.

\subsection{Behavior Trees}
\label{subsec.bt}

\emph{Behavior Trees} are a family of DSLs used for game 
AI~\cite{isla2005,hecker2009my}.
The DSLs vary between languages, but they usually include sequence (\code{SEQ}) 
and selection (\code{SEL}) combinators to model concurrent creature behavior.
%
The \code{SEQ} can be understood as short-circuit evaluation of an `and',
while the \code{SEL} corresponds to an `or'.
%
This skeleton is extensible with leaves to test and set properties, perform 
animations and sounds, etc., and is an effective alternative to finite state 
machines for authoring game AI.

However, because the evaluation of trees extend across multiple game frames, 
specifying node behaviors in generic languages via event-driven programming 
becomes a challenge due to ``stack ripping''~\cite{krohn2007events}.
%
%and there are sufficiently many creatures that it is infeasible for each 
%creature to have its own thread,
%
By lowering the barrier to writing custom nodes and leaves, \CEU lightweight 
event control mechanisms make behavior trees more usable.

Figure~\ref{lst.bt1} describes a generic grammar for behavior trees (ln. 
1--9).
The \code{SEQ} and \code{SEL} tags (ln. 4,6) are recursive and behave as 
described above.
%
The \code{LEAF} tag (ln. 8) receives a reference to an opaque \code{Leaf} data 
type, which is defined externally and is specific to the application domain.
%
The interpreter for behavior trees is abstracted in a class definition (ln.  
11--35) and receives the tree to traverse as the single argument (ln. 11).
The body acquires the return status of the traversal (ln. 12) and returns it as 
the final result (ln. 34).
%
%The traversal takes into account the semantics of the composite nodes as 
%described before.
%
For the \code{SEQ} tag (ln. 14--20), we traverse the \code{first} subtree 
(ln. 15) and only if it succeeds, we traverse the \code{second} subtree (ln.  
19).
%
For the \code{SEL} tag (ln. 21--27), we traverse the \code{first} subtree 
(ln. 22) and only if it fails, we traverse the \code{second} subtree (ln. 
26).
%
Finally, the \code{LEAF} tag (ln. 28--31) delegates the behavior to another 
class, which does real work and is domain specific.
The \code{do Class} syntax (ln. 29--30) creates an anonymous and lexically 
scoped organism and awaits its termination to return the final status (ln.  
31).
The organism itself can contain any valid code in \CEU (including parallel 
compositions) and executes for an arbitrary amount of time~\cite{ceu.mod15}.
%The tree traversal hangs and waits for its return status (ln. 33), which is the 
%expected behavior given that both \code{SEQ} and \code{SEL} nodes execute 
%their children in sequence.

% rebls-15/bts-ceu/btree-1.ceu
\begin{figure}[t]
\begin{lstlisting}[numbers=left,xleftmargin=3em]
data BTree with
   tag NIL ();
or
   tag SEQ (BTree first, BTree second);
or
   tag SEL (BTree first, BTree second);
or
   tag LEAF (Leaf& leaf);
end

class BTreeInterpreter (BTree[]& btree) do
   var int ret =
      traverse t in btree do
         if t:SEQ then
             var int ok = traverse t:SEQ.first;
             if ok == 0 then
                 escape ok;
             end
             ok = traverse t:SEQ.second;
             escape ok;
         else/if t:SEL then
             var int ok = traverse t:SEL.first;
             if ok != 0 then
                 escape ok;
             end
             ok = traverse t:SEL.second;
             escape ok;
         else/if t:LEAF then
            var int ret =
                do LeafHandler(t:LEAF.leaf);
            escape ret;
         end
      end;
   escape ret;
end
\end{lstlisting}
\caption{
A simple grammar of behavior trees with \code{SEQ} and \code{SEL} nodes and a 
straightforward interpreter.
\label{lst.bt1}
}
\end{figure}

\begin{figure}[h]
\begin{lstlisting}[numbers=left,xleftmargin=3em]
pool BTree[] btree =
   new SEQ(SEQ,
         SEL(
           LEAF(SENSE_ON_TABLE(C)),
           LEAF(MOVE_BLOCK_TO_TABLE(C))),
         LEAF(MOVE_BLOCK_TO_BLOCK(B, A)),
         LEAF(MOVE_BLOCK_TO_BLOCK(C, B)));
\end{lstlisting}

\centerline{\includegraphics[scale=0.35]{blocksworld2.eps}}
%\rule{8.5cm}{0.37pt}
\caption{ A \emph{blocks world} behavior tree.
\label{lst.bt1.example}
}
\end{figure}

As an example of a domain, the \emph{blocks world} is a classical planning 
domain in AI~\cite{slaney2001blocks}.
%
The tree in Figure~\ref{lst.bt1.example} is based on the output from a
Contingent-FF benchmark that extends the blocks domain with sensor 
actions~\cite{hoffmann2005contingent}.
%
%The leaves of a behavior tree might include sensor leaves that either succeed 
%or fail, as well as actuator leaves that move blocks and unconditionally 
%succeed.
%
We want to achieve an \code{ABC} stack and assume two decision possibilities, 
as illustrated in the figure.
%
We use a \code{SEL} node (ln. 3) with a sensor leaf (ln. 4) to decide which 
strategy is appropriate:
If \code{C} is not sensed on top of the table, we first move it to the table 
(ln. 5).
Then, in both situations, we stack \code{B} on top of \code{A}, and \code{C} on 
top of \code{B} (ln. 6--7).
%
%If the sensor does not succeed, we move to the second sequence of
%the selection (ln. 4-6): we move C from B to the table
%and B from the table to A. Finally, completing the outer sequence
%that applies to both cases, we move C from the table to B (ln. 7),
%thus achieving an ABC stack.
%
The example illustrates how the behavior tree can exhibit goal-directed 
behavior specified directly by domain designers.
%The \code{traverse} feature allows behavior authored at runtime, which is one 
%of the crucial features of behavior trees.
%
%Alternatively, \code{traverse} allows \CEU to consume at runtime the output of 
%CPU-intensive algorithms such as planners.

\subsection{Logo Turtle}
\label{sec.apps.turtle}

Our second example is an interpreter for a simple variant of the classic Logo
turtle-graphics interpreter \cite{papert.logo}.
The aim of this example is to demonstrate parallel traversal:
we can instruct the turtle to move and rotate at the same time to trace curves.

% We declare a data type which defines our abstract syntax, with each tag 
% representing one of the supported Logo commands. A tree of nodes represents a 
% program, and the interpreter is implemented as a traversal of this tree.

Figure~\ref{lst.turtle} presents the \code{Command} data type (ln. 1--15), 
which specifies the abstract syntax of our Logo variant.
As in traditional Logo, commands can execute in sequence through the \code{SEQ} 
tag (ln. 4), and can also repeat a number of times through the \code{REPEAT} 
tag (ln. 6).
%
We extend the \code{MOVE} and \code{ROTATE} commands to take as arguments the 
speed at which they should affect the turtle (ln. 8,10).
For example, a \code{Command.MOVE(300)} node directs the turtle to move at the 
speed of 300 pixels per second, indefinitely.
%
Therefore, the only way to make the turtle stop moving or rotating is through 
two \CEU-like extensions:
The \code{AWAIT} tag (ln. 12) simply awaits a given number of milliseconds.
The \code{PAROR} tag (ln. 14) launches two commands in parallel, and aborts 
both as soon as one of them terminates.
%
As an example, the program in lines 54--60 makes the turtle to move along a 
semicircle.

The interpreter for the commands is also abstracted in a class definition 
(ln. 17--52).
%
It holds as attributes a reference to a \code{Turtle} object (which implements 
the UI) and a reference to the commands (ln. 18--19).
The execution body of the class uses the \code{traverse} construct to interpret 
the commands (ln. 21--51).
%
The \code{SEQ} tag (ln. 23--25) traverses each of its subcommands in sequence 
(in contrast with \code{BTreeInterpreter}, it does not handle failures).
%
The \code{REPEAT} tag (ln. 27--30) traverses its subcommand the specified number 
of times.
%
The \code{MOVE} and \code{ROTATE} tags (ln. 32--38) rely on predefined classes 
of organisms to update the position and orientation of the received 
\code{turtle}.
%
The \code{AWAIT} tag (ln. 40--41) simply causes the current iteration of the 
\code{traverse} to await the given amount of time.
%
Finally, the \code{PAROR} tag (ln. 43--48) uses the \code{par/or} construct
to traverse both subcommands at the same time:
as soon as one of the subtrees terminates its execution, the other one is 
safely aborted~\cite{ceu.sensys13}.

Note that the entire interpreter block is surrounded by a \code{watching}
construct (ln. 22).
As discussed in Section~\ref{sec.traverse}, the \CEU compiler enforces the 
presence of the guard, due to the use of the \code{cmd} pointer in code that 
spans multiple reactions. This ensures clean abortion in case the AST is 
mutated by code running in other trails.

% rebls-15/turtle/turtle-2.ceu
% rebls-15/turtle/turtle-7.ceu
\begin{figure}[t!]
\begin{lstlisting}[numbers=left,xleftmargin=3em]
data Command with
   tag NOTHING ();
or
   tag SEQ (Command first, Command second);
or
   tag REPEAT (int times, Command command);
or
   tag MOVE (int pixels);
or
   tag ROTATE (int angle);
or
   tag AWAIT (int ms);
or
   tag PAROR (Command first, Command second);
end

class CommandInterpreter (Turtle&    turtle,
                          Command[]& cmds)
do
   traverse cmd in cmds do
      watching cmd do
         if cmd:SEQ then
            traverse cmd:SEQ.first;
            traverse cmd:SEQ.second;

         else/if cmd:REPEAT then
            loop i in cmd:REPEAT.times do
               traverse cmd:REPEAT.command;
            end

         else/if cmd:MOVE then
            do TurtleMove(turtle,
                          cmd:MOVE.pixels);

         else/if cmd:ROTATE then
            do TurtleRotate(turtle,
                            cmd:ROTATE.angle);

         else/if cmd:AWAIT then
            await (cmd:AWAIT.ms) ms;

         else/if cmd:PAROR then
            par/or do
               traverse cmd:PAROR.first;
            with
               traverse cmd:PAROR.second;
            end
         end
      end
   end
end

pool Command[] cmds =
   new PAROR(
         AWAIT(1000),
         PAROR(MOVE(300), ROTATE(180)));

var Turtle turtle;
do CommandInterpreter(turtle, cmds);
\end{lstlisting}
\caption{Grammar, interpreter, and sample program for a Logo Turtle DSL.
\label{lst.turtle}
}
\end{figure}

\subsection{Enqueuing Commands}
\label{sub.enqueuing}

\begin{figure*}[t]
\begin{minipage}[t]{0.22\linewidth}
\begin{lstlisting}[title=CODE-3: \code{Queue} type]
data Queue with
  tag NIL ();
or
  tag ROOT (Queue running,
            Queue waiting,
            Queue tmp);
or
  tag ITEM (Command cmds,
            Queue prv);
end










.
\end{lstlisting}
\end{minipage}
%
\begin{minipage}[t]{0.36\linewidth}
\begin{lstlisting}[numbers=left,xleftmargin=3.5em,title=CODE-4: Queue traversal]
traverse qu in queue do
  watching qu do
    if qu:ROOT then
      loop do
        par/and do
          traverse qu:ROOT.running;
        with
          await qu:ROOT.waiting;
        end
        qu:ROOT.running =
          qu:ROOT.waiting;
        qu:ROOT.waiting =
          new ITEM(NOTHING(), NIL());
      end
    else/if qu:ITEM then
      traverse qu:ITEM.prv;
      do CommandInterpreter(
            turtle, qu:ITEM.cmds);
    end
  end
end
\end{lstlisting}
\end{minipage}
%
\begin{minipage}[t]{0.39\linewidth}
\begin{lstlisting}[numbers=left,xleftmargin=3.5em,title=CODE-5: Enqueuing commands]
input (char*,int,int) ENQUEUE;
every (cmd,vel,time) in ENQUEUE do
  if _strcmp(cmd,"move")==0 then
    queue.ROOT.tmp =
      new ITEM(
            NOTHING(),
            ITEM(
              PAROR(
                MOVE(vel),
                AWAIT(time)),
              NIL()));
  else/if _strcmp(cmd,"rotate")==0 then
    <...> // analogous to the MOVE above
  end
  queue.ROOT.tmp.ITEM.prv.ITEM.prv =
    queue.ROOT.waiting.ITEM.prv;
  queue.ROOT.waiting = queue.ROOT.tmp;
end


.
\end{lstlisting}
\end{minipage}
%
%\rule{17.5cm}{0.37pt}
\caption{ Queue extension for the Turtle DSL of
          Figure~\ref{lst.turtle}.
\label{lst.turtle.queue}
}
\end{figure*}

All examples so far create a fixed tree that does not vary during traversal.
%
Figure~\ref{lst.turtle.queue} extends the Turtle application with a queue of 
pending commands to execute.

We define a new \code{Queue} data type in \emph{CODE-3}:
The \code{ROOT} tag (ln. 4--6) has a \code{runnning} subtree of commands, a 
\code{waiting} queue of pending commands, and a \code{tmp} node to allow 
in-place manipulation of the tree (to be discussed further).
%
The \code{ITEM} tag (ln. 8--9) represents a queue item and contains a 
\code{cmds} subtree with the actual commands to execute (as described in 
Figure~\ref{lst.turtle}: 1--15), and a \code{prv} queue item pointing to an 
older item (i.e., the queue is in reverse order to facilitate insertion).
%
As Figure~\ref{fig.queue-1} illustrates in box \code{0}, a queue instance has a 
single \code{ROOT} node with linked lists of \code{ITEM} nodes in the 
\code{running} and \code{waiting} fields.
Except when creating a new command, the \code{tmp} field is always \code{NIL}.

\begin{figure*}[t]
\centering
\includegraphics[scale=0.24]{queue-fig-2.eps}
\caption{
Enqueuing new commands.
\label{fig.queue-2}
}
\end{figure*}

\begin{figure}[h!]
\centering
\includegraphics[scale=0.24]{queue-fig-1.eps}
\caption{
Swapping \code{waiting} and \code{running} commands.
\label{fig.queue-1}
}
\end{figure}

We define the \code{queue} traversal in \emph{CODE-4}.
%
The \code{ROOT} traversal (ln. 3--14) is a continuous \code{loop} that 
executes the \code{running} subtree and swaps it with the \code{waiting} queue 
on termination.
The \code{par/and} (ln. 5--9) ensures that that the swap only occurs after 
the current \code{running} commands terminate (ln. 6) \emph{and} something (in 
parallel) mutates the \code{waiting} subtree (ln. 8), meaning that the queue 
is no longer empty.
The swapping process (ln. 10--13) is illustrated in Figure~\ref{fig.queue-1}: 
%
\begin{itemize}
%
\item The initial state (box \code{0}) assumes pre-existing \code{running} and 
\code{waiting} items.
%
\item Lines 10--11 assign the \code{waiting} subtree (marked~\MM{B}) to the 
\code{running} field, releasing the old subtree \MM{A}.
Recursive data types in \CEU have \emph{move semantics}, hence, the 
\code{waiting} field is automatically set to the union null type (i.e., 
\code{Queue.NIL}).
%
\item Lines 12--13 assign a new neutral \code{ITEM} with a dummy command 
\code{NOTHING} (box \code{1}:~\MM{C}) to the \code{waiting} field, completing 
the swapping operation.
%
\end{itemize}
%
After the swapping process, the \code{loop} restarts and traverses the new 
\code{running} commands (ln. 4).
%
The \code{ITEM} traversal (ln. 15--18) is straightforward:
first we traverse the previous item (ln. 16), and then we reuse the 
\code{CommandInterpreter} class of Figure~\ref{lst.turtle} to traverse the 
commands (ln. 17--18).

Even though this example mutates the \code{running} field only \emph{after} its 
traversal terminates (ln. 10--11), it is safe to do an arbitrary mutation at 
any time.
Note that the compiler enforces the use of the \code{watching} construct (ln. 
2) which encloses the running turtle interpreter (ln. 17--18).
Hence, if its enclosing \code{ITEM} (ln. 15) is mutated, the \code{watching} 
will awake and abort the interpreter running inside the lexical scope.

The enqueuing of new commands is depicted in \emph{CODE-5}.
The external input event \code{ENQUEUE} (ln. 1) accepts \emph{``move''} and 
\emph{``rotate''} strings with an associated velocity and time (i.e., 
``\code{char*,int,int}'' arguments).
The \code{every} loop (ln. 2--18) reacts to each occurrence of 
\code{ENQUEUE}, creating and enqueuing the requested command, as illustrated in 
Figure~\ref{fig.queue-2}: 
%
\begin{itemize}
%
\item The initial state (box~\code{0}) assumes a pre-existing neutral 
\code{ITEM} in the root of the \code{waiting} field \MM{D}.
%
\item Lines 4--11 assign a new subtree to the \code{tmp} field (box~\code{1}) 
with a new neutral \code{ITEM} (\MM{E}, l. 5--6) linked to the set of 
commands to \code{MOVE} the turtle (\MM{F}, l. 7--11).
%
\item Lines 15--16 move the already \code{waiting} commands (\MM{G}) to the 
tail of \code{tmp}, in the place of \code{NIL} (\MM{H}).
The old location is automatically set to \code{NIL}.
Note that we skip the neutral \code{ITEM} nodes of both \code{waiting} and 
\code{tmp} fields.
This prevents the \code{waiting} root to become \code{NIL} and awake the 
\code{ROOT} node (\emph{CODE-4}: 8) before we finish the enqueuing operation.
%
\item Line 17 moves the \code{tmp} subtree (\MM{E}) back to the \code{waiting} 
field, releasing the abandoned neutral \code{ITEM} (\MM{D}), and notifying the 
\code{ROOT} node that the queue is no longer empty.
The \code{tmp} field is automatically set to \code{NIL}.
Note that the new \code{waiting} subtree preserves the neutral \code{ITEM} 
\MM{E} for subsequent enqueue operations.
%
\end{itemize}

\section{Related Work}
\label{sec.related}

Traversing data reactively in an imperative language requires dealing with 
concurrent updates.
Some attempts make this process more transparent, but performance concerns 
ultimately require the programmer to specify behavior explicitly.
%
One-way dataflow constraints can track updates in data structures in a reactive 
imperative language~\cite{ripdataflow}.
Classes are annotated with constraint handler functions which are recursively 
called on value updates.
%
Another approach focus on incremental computation and uses a combination of 
dynamic dependency graphs and memoization~\cite{selfadjusting}.
Keeping track of dependencies incurs significant overhead: traceable data types
\cite{traceable} mitigates this issue, letting the programmer control the 
granularity of tracked data.
%
In \CEU, tracking pointer updates is explicit (and enforced), and the move 
semantics for recursive data fields propagates changes to tracked pointers 
automatically.
%designed for static memory management based on pools.

Introducing a control structure specifically for traversing recursive data is
unusual, but parallels can be made to other languages.

More general approaches such as generators first appeared in CLU \cite{clu}, 
but their stackless implementation did not support recursion.
%
Icon \cite{icon} allows yielding through recursive functions, but delegation is 
explicit via the \code{suspend} keyword.
%
\begin{comment}
In \cite{icon}, Icon generators are used for implementing
goal-directed programming via ``control backtracking'' similarly to selector
nodes presented in Section \ref{subsec.bt}.
\end{comment}
%
Python originally introduced CLU-like stackless generators in version 2.2,
but those were later internally promoted to coroutines in order to support
recursion. Finally, in version 3.3, a form of delegation was
introduced~\cite{peps}.
%
In contrast, Lua~\cite{lua} has first-class stackful coroutines:
generator functions have to be constructed by wrapping coroutine objects, but 
explicit delegation in recursive calls is not required.
%
\CEU builds its higher-level \code{traverse} construct on organisms, which are 
also a primitive for cooperative multitasking, but with transparent support for 
recursion and concurrency.
This allows composing parallel traversals more naturally in comparison to 
coroutines, which would require a specialized scheduler.

\section{Conclusion}
\label{sec.conclusion}

We presented a new construct for traversing recursive data types
incrementally in the context of \CEU, an imperative reactive language with
synchronous concurrency.
Combining concurrency and safety while traversing recursive data structures is 
not straightforward, specially with support for mutation.
%Furthermore, ensuring that a traversal does not manipulate stale subtrees 
%(originated from mutations) requires a continuous monitoring of nodes.
%For instance, composing parallel constructs during recursion requires that 
%each recursive step spawns new concurrent lines of execution.

The \code{traverse} construct encapsulates an idiom that handles each recursive 
step in a separate organism (\CEU's abstraction mechanism), allowing concurrent 
traversal while preserving the language's safety properties.
A \code{traverse} is tied with its associated data structure, ensuring bounded 
execution time. %, in line with the philosophy of \CEU.
By dealing with concurrency in a primitive control mechanism, we make reactive 
traversal as easy to perform correctly as a recursive function call.

\begin{comment}
Difficult because of
    multiple stack frames
    concurrent stack frames
    persistent stack frames (across reactions, with other parts executing)
    -DONE- static memory management
    -DONE- mutation of the data structure being traversed
\end{comment}

We impose some restrictions on the data structures that we can represent.
On the one hand, the requirement of a tree hierarchy with move semantics 
demands care when designing algorithms to manipulate these structures.
On the other hand, these restrictions enable static memory management with
deterministic deallocation.
Still, we do not feel that the restrictions are prohibitively limiting.
For instance, persistent data structures in functional languages operate under 
similar constraints.

\begin{comment}
Possibilities for future work are the introduction of type arguments for 
\code{data} declarations, and investigating possibilities for relaxing \CEU 
pointer and reference restrictions without sacrificing safety.
% properties on recursive data.
\end{comment}

%\newpage % TTT
\balance
%{\footnotesize
\bibliographystyle{abbrv}
\bibliography{rebls-15}
%}

\balancecolumns
\end{document}
